<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      .container {
        width: 90%;
        max-width: 1000px;
        margin-top: 20px;
        padding: 20px;
        background-color: white;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      #svg-box-container {
        position: relative;
        width: 100%;
        max-width: 100%;
      }

      #diagramDisplayArea {
        min-height: 200px;
        padding: 0;
      }

      .svg-content-responsive {
        display: block;
        /* SVG is inline by default, which can cause scaling issues */
        max-width: 100%;
        /* Limit the width to the parent container */
        max-height: 900px;
        /* Limit the height to 900px */
        margin: auto;
        /* Center the SVG if it's smaller than the parent container */
      }
    </style>
    <script src="https://d3js.org/d3.v6.min.js"></script>
  </head>
  <body>
    <div>
      <div id="diagramDisplayArea"></div>
      <div id="svg-box-container"></div>
      <div
        id="all-metrics"
        style="
          display: flex;
          justify-content: space-around;
          align-items: center;
          width: 100%;
          max-width: 100%;
          flex-wrap: wrap;
        "
      ></div>
    </div>
    <script>
      let boxCounter = 0; // Global counter to manage vertical position of boxes

      function createSVGBoxAtCoordinates(svgContainer, x, y, color, text) {
        const boxWidth = 30;
        const boxHeight = 20;
        const lineLength = 60; // Length of the horizontal line

        // Create an SVG element
        const svg = d3
          .select(svgContainer)
          .append("svg")
          .attr("width", boxWidth + lineLength + 100) // Adjust width to fit line, box, and text
          .attr("height", boxHeight + 10) // Extra height for padding
          .style("position", "absolute")
          .style("left", `${x}px`)
          .style("top", `${y + boxCounter * 27}px`);

        // Draw the horizontal line
        svg
          .append("line")
          .attr("x1", 0)
          .attr("y1", boxHeight / 2 + 4)
          .attr("x2", lineLength)
          .attr("y2", boxHeight / 2 + 5)
          .attr("stroke", color)
          .attr("stroke-width", 4);

        // Create the SVG box (rectangle)
        svg
          .append("rect")
          .attr("x", lineLength)
          .attr("y", 5)
          .attr("width", boxWidth)
          .attr("height", boxHeight)
          .attr("fill", color) // Fill the rectangle with the specified color
          .attr("stroke", color)
          .attr("stroke-width", 2);

        // Add text next to the rectangle
        svg
          .append("text")
          .attr("x", lineLength + boxWidth + 15)
          .attr("y", boxHeight / 2 + 5)
          .attr("dy", ".35em")
          .attr("text-anchor", "start")
          .text(text)
          .attr("fill", color)
          .attr("font-size", "12px");

        boxCounter++; // Increment counter for the next box
      }

      function generateMetricsBox(id, color) {
        const metricsContainer = document.createElement("div");
        metricsContainer.id = id;
        Object.assign(metricsContainer.style, {
          margin: "6px",
          display: "flex",
          justifyContent: "center",
        });
        const metricsBox = document.createElement("div");
        Object.assign(metricsBox.style, {
          padding: "3px",
          border: "1px solid black",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          gap: "2px",
        });
        const circuitBox = document.createElement("div");
        Object.assign(circuitBox.style, {
          height: "5px",
          width: "7px",
          backgroundColor: color,
        });
        const metricsText = document.createElement("div");
        metricsText.textContent = "1x 20A electric feed";
        metricsText.style.fontSize = "10px";
        metricsBox.appendChild(circuitBox);
        metricsBox.appendChild(metricsText);
        metricsContainer.appendChild(metricsBox);
        return metricsContainer;
      }
      function generateMetrics() {
        const container = document.getElementById("all-metrics");
        const nodes = document.querySelectorAll(".circuit-box");
        const seen = [];
        nodes.forEach((node) => {
          if (seen.includes(node.id)) return;
          seen.push(node.id);
          const metricsBox = generateMetricsBox(
            `metrics-${node.id}`,
            node.getAttribute("fill")
          );
          container.appendChild(metricsBox);
        });
      }
      // Function to generate the diagram
      function generateDiagram(
        wide,
        tall,
        perPort,
        aspectRatio,
        doubleLine = false
      ) {
        // Select the diagram display area and clear any previous content
        const diagramArea = d3.select("#diagramDisplayArea");
        diagramArea.html("");
        // Calculate cabinet width based on the aspect ratio
        let boxsizecheck = aspectRatio === "16:9";
        let previousColor;

        let [aspectWidth, aspectHeight] = aspectRatio.split(":").map(Number);
        let cabinetWidth = (100 * aspectWidth) / aspectHeight;
        console.log(boxsizecheck, "cabinetWidth");
        var ratiocheck2 = aspectRatio === "1:1" || aspectRatio === "8:9";
        // Create the SVG element
        const svg = diagramArea
          .append("svg")
          .attr("viewBox", `0 0 ${wide * cabinetWidth} ${tall * 100}`)
          .attr("preserveAspectRatio", "xMidYMid meet")
          .classed("svg-content-responsive", true);
        // Apply geometric precision to shapes in SVG
        svg.style("shape-rendering", "geometricPrecision");
        // Array of colors for each port
        const portColors = [
          "#E62326",
          "#F3722C",
          "#F9C79F",
          "#90BE6D",
          "#37BE6D",
          "#7E7B52",
          "#84C3BE",
          "#43A4AB",
          "#924E7D",
          "#4B5EAC",
          "#000000",
          "#808080",
          "#FF5733",
          "#E74C3C",
          "#FF6347",
          "#2E8B57",
          "#6A5ACD",
          "#32CD32",
          "#4682B4",
          "#DC143C",
          "#8B008B",
          "#556B2F",
          "#B0C4DE",
          "#9932CC",
          "#87CEEB",
          "#FF4500",
          "#DA70D6",
          "#4B0082",
          "#FF1493",
          "#00BFFF",
          "#1E90FF",
          "#FFD700",
          "#FF8C00",
          "#B22222",
          "#FF69B4",
          "#D2B48C",
          "#008B8B",
          "#FFDAB9",
          "#696969",
          "#32CD32",
          "#8B4513",
          "#9370DB",
          "#CD5C5C",
          "#00FA9A",
        ]; // Define arrow markers for each port color
        portColors.forEach((color) => {
          svg
            .append("defs")
            .append("marker")
            .attr("id", `arrowhead-${color}`)
            .attr("markerWidth", "5")
            .attr("markerHeight", "6")
            .attr("refX", "5")
            .attr("refY", "3")
            .attr("orient", "auto")
            .attr("viewBox", "0 0 6 6")
            .append("path")
            .attr("d", "M0,0 L6,3 L0,6")
            .attr("fill", color === "dotted-black" ? "#000000" : color);
        });
        // Initialize cabinet numbering and counter
        let currentCabinet = 1;
        let cabinetCounter = 0;
        // Define circle radius and green rectangle dimensions
        const circleRadius = 5;
        const greenRectWidth = cabinetWidth / 4;
        const greenRectHeight = 10;
        // Calculate middle rows for green box placement
        const middleRow = Math.floor(tall / 2);
        const upperMiddleRow = Math.ceil(tall / 2) - 1;
        // Array to keep track of columns with the start of a port
        let columnsWithPortStart = Array(wide).fill(false);
        for (let i = 0; i < wide * tall; i++) {
          let column = Math.floor(i / tall);
          if (i % perPort === 0) {
            columnsWithPortStart[column] = true;
          }
        }
        // Line generator for Bezier curves
        const lineGenerator1 = d3
          .line()
          .curve(d3.curveBasis)
          .x((d) => d.x)
          .y((d) => d.y);
        function drawCabinet(x, y, portColor, rect, curve, line, line2color) {
          let greenBoxY = y * 100 + 75 - greenRectHeight / 2;
          let greenBoxX = boxsizecheck
            ? x * cabinetWidth + cabinetWidth / 2 - greenRectWidth - 30
            : x * cabinetWidth + cabinetWidth / 2 - greenRectWidth - 10;
          let startY = greenBoxY + greenRectHeight / 2;
          let startX =
            x * cabinetWidth + cabinetWidth / 2 - greenRectWidth / 2 - 2;
          let endX = x * cabinetWidth + cabinetWidth / 2;
          let endY = y * 100 + 50 + greenRectHeight / 2;
          let controlX = (startX + endX) / 2 + 4;
          let controlY = startY / 2 + endY / 2 + 4;
          let startX1 = startX;
          let startY1 = startY;
          console.log(
            `M${startX},${startY - 4} Q${controlX},${controlY} ${endX},${endY}`
          );
          if (aspectRatio === "16:9") {
            endX1 = endX + cabinetWidth / 2 + greenRectWidth + 12;
            //  console.log(endX1, "endX1");
          } else {
            endX1 = endX + cabinetWidth / 2 + greenRectWidth + 6;
          }
          // this is left rectangle that is on every first cabinent or box
          if (rect === 1) {
            svg
              .append("rect")
              .attr("class", "circuit-box")
              .attr("id", `circuit-box-${portColor}`)
              .attr("x", greenBoxX)
              .attr("y", greenBoxY)
              .attr("width", greenRectWidth)
              .attr("height", greenRectHeight + (boxsizecheck ? 5 : 0))
              .attr("fill", line2color)
              .attr("stroke", line2color)
              .attr("stroke-width", 2);
            //right rectangle that is on every first cabinent or box
            if (doubleLine) {
              svg
                .append("rect")
                .attr("class", "circuit-box")
                .attr("id", `circuit-box-${line2color}`)
                .attr("x", greenBoxX + (boxsizecheck ? 100 : 45))
                .attr("y", greenBoxY)
                .attr("width", greenRectWidth)
                .attr("height", greenRectHeight + (boxsizecheck ? 5 : 0))
                .attr("fill", portColor)
                .attr("stroke", portColor)
                .attr("stroke-width", 2);
            }
          }
          if (curve === 1) {
            if (aspectRatio === "1:1" || aspectRatio === "8:9") {
              const markerId2 = createArrowheadMarker(svg, line2color);
              svg
                .append("path")
                .attr(
                  "d",
                  `M${startX},${startY} Q${controlX - 1},${controlY + 4} ${
                    endX - 3
                  },${endY + 8}`
                )
                .attr("fill", "none")
                .attr("stroke", line2color)
                .attr("stroke-width", 2)
                .attr("marker-end", `url(#${markerId2})`);
            } else {
              const markerId2 = createArrowheadMarker(svg, line2color);
              svg
                .append("path")
                .attr(
                  "d",
                  `M${startX - 20},${startY} Q${controlX + 5},${
                    controlY + 15
                  } ${endX - 2},${endY + 8}`
                )
                .attr("fill", "none")
                .attr("stroke", line2color)
                .attr("stroke-width", 2)
                .attr("marker-end", `url(#${markerId2})`);
            }
            //its a curve line that is on every right first cabinent or box
            if (doubleLine) {
              //  var ratiocheck3 = aspectRatio === "1:1" || aspectRatio === "8:9";
              if (ratiocheck2) {
                const markerId3 = createArrowheadMarker(svg, portColor);
                svg
                  .append("path")
                  .attr(
                    "d",
                    `M${startX + 40},${startY} Q${controlX + 7},${
                      ratiocheck2 ? controlY + 8 : 7
                    } ${endX + 4},${endY + 8}`
                  )
                  .attr("fill", "none")
                  .attr("stroke", portColor)
                  .attr("stroke-width", 2)
                  .attr("marker-end", `url(#${markerId3})`);
              } else {
                const markerId3 = createArrowheadMarker(svg, portColor);
                svg
                  .append("path")
                  .attr(
                    "d",
                    `M${startX + 70},${startY} Q${controlX + 12},${
                      controlY + 15
                    } ${endX + 4},${endY + 8}`
                  )
                  .attr("fill", "none")
                  .attr("stroke", portColor)
                  .attr("stroke-width", 2)
                  .attr("marker-end", `url(#${markerId3})`);
              }
            }
          }
          if (curve === 2) {
            const markerId4 = createArrowheadMarker(svg, line2color);
            svg
              .append("path")
              .attr(
                "d",
                `M${startX - 10},${startY - 2} Q${
                  controlX + (boxsizecheck ? 5 : 0)
                },${controlY + 5} ${endX - 3},${endY + 9}`
              )
              .attr("fill", "none")
              .attr("stroke", line2color)
              .attr("stroke-width", 2)
              .attr("marker-end", `url(#${markerId4})`);
            //its a curve line that is on every right first cabinent or box
            if (doubleLine) {
              const markerId5 = createArrowheadMarker(svg, portColor);
              //  svg.append('path')
              //    .attr('d', `M${startX},${startY+5} Q${controlX},${controlY+5} ${endX},${endY}`)
              //    .attr('fill', 'none')
              //    .attr('stroke', portColor)
              //    .attr('stroke-width', 2);
              svg
                .append("path")
                .attr(
                  "d",
                  `M${boxsizecheck ? startX - 17 : startX - 4.5},${
                    boxsizecheck ? startY + 10 : startY + 5
                  } Q${controlX + (boxsizecheck ? 10 : 5)},${
                    boxsizecheck ? controlY + 17 : controlY + 10
                  } ${endX + 3},${endY + 9}`
                )
                .attr("fill", "none")
                .attr("stroke", portColor)
                .attr("stroke-width", 2)
                .attr("marker-end", `url(#${markerId5})`);
            }
          }
          //  its the horizontal line on top
          if (line === 1) {
            svg.select("#arrowhead polygon").attr("fill", line2color);
            // Define the arrowhead marker
            const defs = svg.append("defs");
            svg
              .append("path")
              .attr(
                "d",
                `M ${startX1 - 5},${
                  startY1 - (boxsizecheck ? -1 : 2)
                } L ${endX1},${startY1 - 2}`
              )
              .attr("fill", "none")
              .attr("stroke", line2color)
              .attr("stroke-width", 2);
            //second line
            if (doubleLine) {
              svg.select("#arrowhead polygon").attr("fill", portColor);
              // Define the arrowhead marker
              const defs = svg.append("defs");
              svg
                .append("path")
                .attr(
                  "d",
                  `M ${startX1 + (boxsizecheck ? 50 : 30)},${
                    boxsizecheck ? startY1 + 10 : startY1 + 5
                  } L ${endX1},${boxsizecheck ? startY1 + 10 : startY1 + 5}`
                )
                .attr("fill", "none")
                .attr("stroke", portColor)
                .attr("stroke-width", 2);
            }
          }
        }
        function drawArrowhead(color) {
          const defs = svg.append("defs");
          defs
            .append("marker")
            .attr("id", "arrowhead")
            .attr("markerWidth", "5")
            .attr("markerHeight", "6")
            .attr("refX", "0")
            .attr("refY", "2")
            .attr("orient", "auto")
            .append("polygon")
            .attr("points", "0 0, 5 2, 0 4")
            .attr("fill", color);
        }
        function createArrowheadMarker(svg, color) {
          const markerId = `arrowhead-${color.replace("#", "")}`; // Create a unique ID based on color
          //it is top line arrow that is curved
          const defs = svg.append("defs");
          defs
            .append("marker")
            .attr("id", markerId)
            .attr("markerWidth", "5")
            .attr("markerHeight", "6")
            .attr("refX", "0")
            .attr("refY", "2")
            .attr("orient", "auto")
            .append("polygon")
            .attr("points", "0 0, 5 2, 0 4")
            .attr("fill", color);
          return markerId;
        }
        let previousColor2 = null;

        function drawCabinetspecial(x, y, portColor, num, temp1, line2color) {
          let greenBoxY = y * 100 + 75 - greenRectHeight / 2;
          let greenBoxX =
            x * cabinetWidth + cabinetWidth / 2 - greenRectWidth - 10;
          let startY = greenBoxY + greenRectHeight / 2;
          let startX =
            x * cabinetWidth + cabinetWidth / 2 - greenRectWidth / 2 - 2;
          let endX = x * cabinetWidth + cabinetWidth / 2;
          let endY = y * 100 + 50 + greenRectHeight / 2 + 5;
          let controlX = (startX + endX) / 2 + 4;
          let controlY = startY / 2 + endY / 2 + 4;

          // Adjust the control points to create a smoother curve
          let verticalLength = 60 - x * 5; // Adjust vertical length to decrease more
          let controlX1 = startX + 8; // Slightly to the right of the vertical line
          let controlY1 = startY - verticalLength - 5; // Upward curve

          if (aspectRatio === "16:9") {
            endX1 = endX + cabinetWidth / 2 + greenRectWidth + 12;
          } else {
            endX1 = endX + cabinetWidth / 2 + greenRectWidth + 6;
          }
          let startX1 = startX;
          let startY1 = startY;

          // Draw top boxes
          if (num === 1 || num === 2) {
            svg
              .append("rect")
              .attr("class", "circuit-box")
              .attr("id", `circuit-box-${portColor}`)
              .attr("x", greenBoxX)
              .attr("y", greenBoxY)
              .attr("width", greenRectWidth)
              .attr("height", greenRectHeight + (boxsizecheck ? 5 : 0))
              .attr("fill", portColor)
              .attr("stroke", portColor);

            if (doubleLine) {
              svg
                .append("rect")
                .attr("class", "circuit-box")
                .attr("id", `circuit-box-${line2color}`)
                .attr("x", greenBoxX + (boxsizecheck ? 80 : 50))
                .attr("y", greenBoxY)
                .attr("width", greenRectWidth)
                .attr("height", greenRectHeight + (boxsizecheck ? 5 : 0))
                .attr("fill", line2color)
                .attr("stroke", line2color);
            }
          }

          // Draw curves and arrows
          if (aspectRatio === "1:1" || aspectRatio === "8:9") {
            const markerId = createArrowheadMarker(svg, portColor);
            svg
              .append("path")
              .attr(
                "d",
                `M${startX},${startY} Q${controlX},${controlY + 1} ${
                  endX - 2.5
                },${endY + 3}`
              )
              .attr("fill", "none")
              .attr("stroke", portColor)
              .attr("stroke-width", 2)
              .attr("marker-end", `url(#${markerId})`);
          } else {
            const markerId = createArrowheadMarker(svg, portColor);
            svg
              .append("path")
              .attr(
                "d",
                `M${startX - 10},${startY - 2} Q${controlX + 4},${
                  controlY + 3
                } ${endX - 3},${endY + 4}`
              )
              .attr("fill", "none")
              .attr("stroke", portColor)
              .attr("stroke-width", 2)
              .attr("marker-end", `url(#${markerId})`);
          }

          // Second arrow if doubleLine
          if (doubleLine) {
            const markerIdX = createArrowheadMarker(svg, line2color);
            if (num === 1 || num === 2) {
              if (aspectRatio === "1:1" || aspectRatio === "8:9") {
                svg
                  .append("path")
                  .attr(
                    "d",
                    `M${startX + 45},${startY + 5} Q${controlX + 5},${
                      controlY + 5
                    } ${endX + 2},${endY + 4}`
                  )
                  .attr("fill", "none")
                  .attr("stroke", line2color)
                  .attr("stroke-width", 2)
                  .attr("marker-end", `url(#${markerIdX})`);
              } else {
                svg
                  .append("path")
                  .attr(
                    "d",
                    `M${startX + 50},${startY + 5} Q${controlX + 10},${
                      controlY + 10
                    } ${endX + 2},${endY + 4}`
                  )
                  .attr("fill", "none")
                  .attr("stroke", line2color)
                  .attr("stroke-width", 2)
                  .attr("marker-end", `url(#${markerIdX})`);
              }
            } else {
              if (aspectRatio === "1:1" || aspectRatio === "8:9") {
                svg
                  .append("path")
                  .attr(
                    "d",
                    `M${startX - 7},${startY + 5} Q${controlX + 3},${
                      controlY + 8
                    } ${endX + 2},${endY + 3}`
                  )
                  .attr("fill", "none")
                  .attr("stroke", line2color)
                  .attr("stroke-width", 2)
                  .attr("marker-end", `url(#${markerIdX})`);
              } else {
                svg
                  .append("path")
                  .attr(
                    "d",
                    `M${startX - 10},${startY + 5} Q${controlX + 8},${
                      controlY + 10
                    } ${endX + 2},${endY + 4}`
                  )
                  .attr("fill", "none")
                  .attr("stroke", line2color)
                  .attr("stroke-width", 2)
                  .attr("marker-end", `url(#${markerIdX})`);
              }
            }
          }

          var ratiocheck = aspectRatio === "1:1" || aspectRatio === "8:9";
          if (num === 1 && temp1 === 1) {
            svg
              .append("path")
              .attr(
                "d",
                `M${startX1},${ratiocheck ? startY1 : startY1 - 2} L ${
                  ratiocheck ? endX1 + 6 : endX1
                },${ratiocheck ? startY1 : startY1 - 2}`
              )
              .attr("fill", portColor)
              .attr("stroke", portColor)
              .attr("stroke-width", 2);

            if (doubleLine) {
              svg
                .append("path")
                .attr(
                  "d",
                  `M${startX1 + (ratiocheck ? 30 : 50)},${
                    ratiocheck ? startY1 + 5 : startY1 + 5
                  } L ${endX1},${ratiocheck ? startY1 + 5 : startY1 + 5}`
                )
                .attr("fill", line2color)
                .attr("stroke", line2color)
                .attr("stroke-width", 2);
            }
          }

          // Add vertical line that decreases
          svg
            .append("path")
            .attr(
              "d",
              `M${startX},${startY - 1} V${startY - verticalLength + 10}`
            )
            .attr("stroke", portColor)
            .attr("stroke-width", 2);
          // curve
          svg
            .append("path")
            .attr(
              "d",
              `M${startX},${startY - verticalLength + 14} Q${startX - 4},${
                startY - verticalLength - 0
              } ${startX + 30},${startY - verticalLength + 3}`
            )
            .attr("fill", "none")
            .attr("stroke", portColor)
            .attr("stroke-width", 2);

          // Curve between vertical and horizontal line

          if (previousColor2 !== portColor) {
            // Add the horizontal line spanning the entire row
            svg
              .append("path")
              .attr(
                "d",
                `M${startX + 40},${startY - verticalLength + 3} Q${
                  startX + 5
                },${startY - verticalLength + 5},${startX + 35},${
                  startY - verticalLength + 3
                } H${endX + cabinetWidth * wide}`
              )
              .attr("stroke", portColor)
              .attr("stroke-width", 2);
          } else {
          }
          previousColor2 = portColor;
        }

        function findLargestMultiple(number, limit) {
          // Calculate the largest multiple
          let largestMultiple = Math.floor(limit / number) * number;
          if (largestMultiple === 0) {
            largestMultiple = perPort - 1;
          }
          return largestMultiple;
        }
        let rowsCoveredByLines = 0;
        let coveredRowsSet = new Set();
        let overallPortCounter = 0;
        // Main loop to iterate over columns and rows
        let coveredRows = 0;
        let z = 0;
        totalCount = 0;
        portIndex = 0;
        portIndex2 = 0;
        while (coveredRows < tall) {
          // Update startY and endY for each iteration
          let startY = tall - 1 - coveredRows;
          let endY = tall - Math.min(tall, coveredRows + perPort) - 1;

          difference = startY - endY;
          z = z + 1;
          //x= x+maxCabinetHeight;
          let portColor = portColors[portIndex];
          let line2color = portColors[portIndex2];
          // coveredRows=coveredRows+difference;
          // console.log("reporting diff and length to coverRows before",difference,lengthToCover);

          if (difference >= perPort) {
            lengthToCover = perPort - 1;
          } else lengthToCover = findLargestMultiple(difference, perPort);
          let twoCount = 0;
          let rowsx = 0;
          let res = 0;
          for (let x = 0; x < wide; x++) {
            let stepY = -1;
            let count = 0;
            let rowno = 0;
            if (
              overallPortCounter >= lengthToCover ||
              overallPortCounter === 0
            ) {
              overallPortCounter = 0; // Reset the counter
              portIndex = (portIndex + 1) % portColors.length; // Increment and wrap around portIndex
              portColor = portColors[portIndex]; // Update portColor based on new portIndex
              portIndex2 = (portIndex2 + 3) % portColors.length;
              line2color = portColors[portIndex2];
            }
            y = startY;
            if (difference > 2) {
              let temp = 0;
              //   this logic for lower rectangles
              drawCabinet(x, y, portColor, 1, 1, 0, line2color);
            }
            if (difference === 2) {
              //  let temp=1;
              //  twoCount++;
              let rowsunderCover = lengthToCover / 2;
              if (overallPortCounter % 2 === 0 && overallPortCounter !== 0) {
                rowsx++;
              }
              if (overallPortCounter === 0) {
                rowsx = 0;
                res = 0;
              }
              console.log(rowsx, "rowsX");
              result = Math.floor(lengthToCover / 4);
              //  let rect = twoCount % 2 === 1 ? 1 : 0;
              //  let curve=twoCount % 2 === 0 ? 1 : 0;
              //  let line=1
              //  result = Math.floor(lengthToCover/4);
              let check = rowsx % 2 === 1;
              if (check) {
                let rect = 0;
                let curve = 2;
                let line = 0;
                // 3and 4 column horizon
                drawCabinet(x, y, portColor, rect, curve, 0, line2color);
              }
              if (rowsx % 2 === 0) {
                res++;
                let rect = 1;
                let curve = 1;
                let line = 1;
                if (res <= result && x < wide - 1) {
                  // 4 5 3  checkline for no line
                  let rect = 1;
                  let curve = 1;
                  //  if(){
                  //  let line = 1;
                  //    }
                  //   else{
                  let line = 1;
                  //  }
                  drawCabinet(x, y, portColor, rect, curve, line, line2color);
                } else {
                  let rect = 1;
                  let curve = 1;
                  let line = 0;
                  drawCabinet(x, y, portColor, rect, curve, line, line2color);
                }
              }
              twoCount++;
              if (lengthToCover === overallPortCounter) {
                twoCount = 0;
              }
              // drawCabinet(x,y,portColor,rect,curve,line,line2color);
            }
            const svgContainer = document.getElementById("svg-box-container");
            // Loop through each cabinet
            for (let y = startY; y > endY; y += stepY) {
              //let portIndex = x%
              let isDotted = portColor === "dotted-black";
              //box  or grid
              const rect = svg
                .append("rect")
                .attr("x", x * cabinetWidth)
                .attr("y", y * 100)
                .attr("width", cabinetWidth)
                .attr("height", 100)
                .attr("fill", "none")
                .attr("stroke", "#000000")
                .attr("stroke-width", 2)
                .lower();
              //  circle circuit
              //circle left
              const circleleft = svg
                .append("circle")
                .attr("cx", x * cabinetWidth + cabinetWidth / 2)
                .attr("cy", y * 100 + 50)
                .attr("r", circleRadius)
                .attr("stroke", "#9673A6")
                .attr("fill", "#E1D5E7")
                .attr("stroke-width", 2);
              // this code generate the horizontal line and vertical line

              if ((currentCabinet < wide * tall, difference > 1)) {
                count += 1;
                overallPortCounter++;
                let targetY = y + stepY;

                // Vertical connections from the bottom to the first column
                if (targetY !== endY) {
                  totalCount += 1;
                  let lineX = x * cabinetWidth + cabinetWidth / 2;
                  let lineY1 =
                    y * 100 + 50 + (stepY === 1 ? circleRadius : -circleRadius);
                  let lineY2 =
                    targetY * 100 +
                    50 +
                    (stepY === 1 ? -circleRadius : circleRadius);
                  let points1 = [
                    { x: doubleLine ? lineX - 2 : lineX, y: lineY1 },
                    { x: doubleLine ? lineX - 2 : lineX, y: lineY2 },
                  ];
                  let points2 = [
                    { x: lineX + 3, y: lineY1 },
                    { x: lineX + 3, y: lineY2 },
                  ];

                  svg
                    .append("path")
                    .attr("d", lineGenerator1(points1))
                    .attr("stroke", isDotted ? "#000000" : line2color)
                    .attr("stroke-width", 2)
                    .attr("stroke-dasharray", isDotted ? "4, 4" : "")
                    .attr(
                      "marker-end",
                      `url(#arrowhead-${
                        isDotted ? "dotted-black" : line2color
                      })`
                    );

                  if (doubleLine) {
                    svg
                      .append("path")
                      .attr("d", lineGenerator1(points2))
                      .attr("stroke", isDotted ? "#000000" : portColor)
                      .attr("stroke-width", 2)
                      .attr("stroke-dasharray", isDotted ? "4, 4" : "")
                      .attr(
                        "marker-end",
                        `url(#arrowhead-${
                          isDotted ? "dotted-black" : portColor
                        })`
                      );
                  }
                }

                // Only process for the bottom grid row
                if (y === startY) {
                  totalCount += 1;
                  let lineX = x * cabinetWidth + cabinetWidth / 2;
                  let lineY1 =
                    y * 100 + 50 + (stepY === 1 ? circleRadius : -circleRadius);
                  let lineY2 =
                    targetY * 100 +
                    50 +
                    (stepY === 1 ? -circleRadius : circleRadius);

                  // Calculate variable vertical lengths
                  let verticalLength = 130 - x * 15; // Adjust vertical length to decrease progressively

                  // this is vertical line that joins with horizontal line
                  svg
                    .append("path")
                    .attr(
                      "d",
                      `M${!ratiocheck2 ? lineX - 35 : lineX - 15.5},${
                        lineY1 + 28
                      } V${lineY1 - verticalLength + 25}`
                    )
                    .attr("stroke", isDotted ? "#000000" : line2color)
                    .attr("stroke-width", 2);

                  if (doubleLine) {
                    svg
                      .append("path")
                      .attr(
                        "d",
                        `M${!ratiocheck2 ? lineX + 32 : lineX + 15},${
                          lineY1 + 25
                        } V${lineY1 - verticalLength + 5}`
                      )
                      .attr("stroke", isDotted ? "#000000" : portColor)
                      .attr("stroke-width", 2);
                  }

                  // Control points for the curve
                  let controlX1 = lineX + 10; // Slightly to the right of the vertical line
                  let controlY1 = lineY1 - verticalLength - 10;

                  // Adjusted starting point to where the vertical line ends
                  if (previousColor !== line2color) {
                    svg
                      .append("path")
                      .attr(
                        "d",
                        `M${!ratiocheck2 ? lineX - 35.3 : lineX - 15.2},${
                          !ratiocheck2
                            ? lineY1 - verticalLength + 26
                            : lineY1 - verticalLength + 30
                        } Q${controlX1 - 30},${controlY1 + 6} ${lineX + 10},${
                          lineY1 - verticalLength
                        }`
                      )
                      .attr("fill", "none")
                      .attr("stroke", line2color)
                      .attr("stroke-width", 2);
                    // if (doubleLine) {
                    //   svg
                    //     .append("path")
                    //     .attr(
                    //       "d",
                    //       `M${!ratiocheck2 ? lineX - 35.3 : lineX - 15.2},${
                    //         !ratiocheck2
                    //           ? lineY1 - verticalLength + 26
                    //           : lineY1 - verticalLength + 35
                    //       } Q${controlX1 - 30},${controlY1 + 6} ${lineX + 10},${
                    //         lineY1 - verticalLength
                    //       }`
                    //     )
                    //     .attr("fill", "none")
                    //     .attr("stroke", line2color)
                    //     .attr("stroke-width", 2);
                    // }
                  } else {
                    svg
                      .append("path")
                      .attr(
                        "d",
                        `M${!ratiocheck2 ? lineX - 35.5 : lineX - 15.2},${
                          !ratiocheck2
                            ? lineY1 - verticalLength + 26
                            : lineY1 - verticalLength + 30
                        } Q${!ratiocheck2 ? controlX1 - 40 : controlX1 - 28},${
                          controlY1 + 16
                        } ${lineX},${lineY1 - verticalLength}`
                      )
                      .attr("fill", "none")
                      .attr("stroke", line2color)
                      .attr("stroke-width", 2);
                  }

                  //  horizontal movement across the entire row

                  if (previousColor !== line2color) {
                    const horizontalLineLength = cabinetWidth * wide - x * 100; // Adjust the decrement factor as needed
                    svg
                      .append("path")
                      .attr(
                        "d",
                        `M${!ratiocheck2 ? lineX : lineX},${
                          lineY1 - verticalLength
                        } Q${controlX1},${controlY1 + 10} ${
                          lineX + horizontalLineLength
                        },${lineY1 - verticalLength}`
                      )
                      .attr("stroke", isDotted ? "#000000" : line2color)
                      .attr("stroke-width", 2)
                      .attr("stroke-dasharray", isDotted ? "4, 4" : "");

                    if (doubleLine) {
                      svg
                        .append("path")
                        .attr(
                          "d",
                          `M${!ratiocheck2 ? lineX + 33 : lineX + 16},${
                            lineY1 - verticalLength + 5
                          } Q${controlX1},${controlY1 + 13} ${
                            lineX + cabinetWidth * (wide + 15)
                          },${lineY1 - verticalLength}`
                        )
                        .attr("stroke", isDotted ? "#000000" : portColor)
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", isDotted ? "4, 4" : "");
                    }

                    // Calling createSVGBoxAtCoordinates function to generate the SVG box at the end of the horizontal line
                    const boxX = cabinetWidth * wide + tall * 40;
                    const boxY = cabinetWidth - 447; // Call createSVGBoxAtCoordinates function
                    createSVGBoxAtCoordinates(
                      svgContainer,
                      boxX,
                      boxY,
                      line2color,
                      "20A Feed"
                    );
                  } else {
                    svg
                      .append("path")
                      .attr(
                        "d",
                        `M${!ratiocheck2 ? lineX - 0 : lineX},${
                          lineY1 - verticalLength
                        } Q${controlX1},${controlY1 + 8} ${
                          lineX + (cabinetWidth * wide) / 12
                        },${lineY1 - verticalLength - 15}` // Adjusted control points for smoother curve
                      )
                      .attr("stroke", isDotted ? "#000000" : line2color)
                      .attr("stroke-width", 2)
                      .attr("stroke-dasharray", isDotted ? "4, 4" : "");

                    // Right line or arrow with curve
                    if (doubleLine) {
                      svg
                        .append("path")
                        .attr(
                          "d",
                          `M${!ratiocheck2 ? lineX + 33 : lineX + 15},${
                            lineY1 - verticalLength + 4
                          } Q${controlX1},${controlY1 + 15} ${
                            lineX + (cabinetWidth * (wide + 15)) / 20
                          },${lineY1 - verticalLength - 10}`
                        )
                        .attr("stroke", isDotted ? "#000000" : portColor)
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", isDotted ? "4, 4" : "");
                    }
                  }
                }
                previousColor = line2color;
              }

              if (difference === 1) {
                let y = 0;
                let lineY = y * 100 + 30; // y-coordinate for the horizontal line, assuming 'y' is the row number
                let count = 0;
                let cableCover = Math.min(perPort - 1, 3);
                let portindex = 0;
                let portindex2 = 0;
                let count1 = 0;
                let portindexs = 0;
                let portindexs2 = 0;
                let random = Math.floor(Math.random() * (25 - 2 + 1)) + 2;

                for (let j = 0; j < wide; j++) {
                  portindexs = portindexs % 7;
                  portindexs2 = portindexs + random;
                  line2color1 = portColors[portindexs2];
                  portColor1 = portColors[portindexs];
                  num = 0;
                  let check2 =
                    !(count1 - cableCover === 0 || count1 % 2 === 1) &&
                    j !== wide - 1;
                  if (check2) {
                    num = 1;
                    // j=2 y=0
                    drawCabinetspecial(j, y, portColor1, num, 1, line2color1);
                    // if(j===wide-3){
                    //    drawCabinetspecial(j, y, portColor1,1,0);
                    // }
                  }
                  //this check shows last rectangle fix the rectangle to - 1 from wide
                  if (j === wide - 1 && count1 < 1) {
                    drawCabinetspecial(j, y, portColor1, 2, 0, line2color1);
                  } else if (j === wide || count1 === 2) {
                    drawCabinetspecial(j, y, portColor1, 1, 0, line2color1);
                  } else {
                    drawCabinetspecial(j, y, portColor1, num, 0, line2color1);
                  }

                  if (count1 - cableCover === 0) {
                    //count1 = 0; // Reset count and skip this column
                    portindexs++;
                    portindexs2++;
                    count1 = 0;
                    continue;
                  }
                  count1++;
                }
              }
              currentCabinet++;
              cabinetCounter++;
              if (
                cabinetCounter % perPort === 0 &&
                currentCabinet <= wide * tall
              ) {
                cabinetCounter = 0;
              }
            }
          }

          //let x=0;
          coveredRows = coveredRows + difference;
          //x= x+maxCabinetHeight;
        }
        generateMetrics();
      }
      generateDiagram(5, 8, 4, "1:1", false);
    </script>
  </body>
</html>
